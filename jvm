类加载
1.	在Java代码中，类型的加载、连接与初始化过程都是在程序运行期间完成的
2.	类初始化过程
1）	加载：就是把二进制形式的Java类型读入Java虚拟机中
2）	准备：为类变量分配内存，设置默认值。但是在到达初始化之前，类变量都没与初始化为真正的初始值。
3）	解析：解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，吧这些符号引用替换成直接引用的过程
4）	初始化：为类变量赋予正确的初始值
3.	类的初始化步骤
1）	假如这个类还没有被加载和连接，那就先进行加载和连接
2）	加入类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
3）	假如类中存在初始化语句，那就依次执行这些初始化语句
4.	类的加载的最终产品是位于内存中的Class对象。
1）	Class对象封装了类在方法区内的内存结构，并且向Java程序员提供了访问方法区内的数据结构的接口
2）	因此Class对象是整个反射的入口，可以获取对应的类的所有信息
5.	类加载器（两种类型）
1）	Java虚拟机自带的类加载器
	根类加载器（Bootstrap）， 
	没有父类加载器。负责加载Java虚拟机的核心库，如java.lang.*等。
	加载路径由系统属性sun.boot.class.path指定
	根类加载器实现依赖于地城操作系统，属于虚拟机的实现的一部分，它并没有继承java.lang.ClassLoader类
	扩展类加载器（Extension）
	父加载器为启动类加载器
	加载目录：系统属性指定的java.ext.dirs或从jdk的安装路径jre\lib\ext下进行加载(用户创建的jar放入此目录时，其中的类也会自动由扩展类加载器来加载)
	是java.lang.ClassLoader的子类
	纯Java类
	系统（应用）类加载器（System）
	父加载器为扩展类加载器
	加载路径：环境变量classpath或系统属性java.class.path所指定的目录
	是用户自定义加载器的父加载器
	纯Java类，是java.lang.ClassLoader类的子类
	
2）	用户自己定义的类加载器
	Java.lang.ClassLoader的子类，用户可以定制类的加载方式
6.	类加载器双亲委托机制的好处
1）	可以确保Java核心类库的安全：所有的Java应用都至少会引用java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到JVM中。如果这个加载过程是由Java应用自己的类加载器完成的，那么可能会再JVM中存在多个版本的java.lang.Object类，而且这些类之间还是不兼容的，相互不可见的（正是命名空间在发挥着作用）
2）	可以确保Java核心类库所提供的类不会被自定义的类所取代
3）	不同的类加载器可以为相同名称（binary name）的类创建额外的命名空间。相同名称的类可以并存在JVM中，只需要用不同的类加载器来加载他们即可。不同类加载器所加载的类他们之间是不兼容的，这就相当于在JVM内部创建了一个又一个相互隔离的Java类空间，这类技术在很多框架中都得到了实际应用。
7.	类加载器并不需要等到某个类被首次主动使用时再加载它
4）	JVM允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件的缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）
5）	如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误
8.	类的验证
1）	类被加载后，就进入了连接阶段，连接就是将已经读入内存的类的二进制数据合并到虚拟机的运行时环境上
2）	类的验证内容
	类文件结构的检查
	语义检查
	字节码验证
	二进制兼容性的验证
9.	类的准备
1）在准备阶段，Java虚拟机为类的静态变量分配内存，并设置默认的初始值。
10.	类的初始化：
1）	在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值
2）	静态变量的初始化有两种途径：
	在静态变量的声明处进行初始化
	在静态代码块中进行初始化
3）	静态变量的声明语句和静态代码块都被看作类的初始化语句，Java虚拟机会按照初始化语句在类文件中的先后顺序来依次执行他们。
4）	类初始的步骤
	假如这个类还没有被加载和连接，那就先进行加载和连接
	假如类存在直接父类，并且这个父类还没有被加初始化，那就先初始化直接父类
	假如类中存在初始化语句，那就依次执行这些初始化语句
5）	
11.	类的初始化时机：首次被主动使用
1）	当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口
	初始化一个类时，并不会先初始化它所实现的接口
	初始化一个接口时，并不会先初始化它的父接口
2）	因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化，只有当程序首次主动使用特定接口的静态变量时，才会导致该接口的初始化
3）	调用ClassLoader的loadClass()加载一个类，并不是对类的主动使用个，不会导致类的初始化
12.	类加载器
1）	类加载器用来把类加载到Java虚拟机当中，从JDK1.2版本开始，类的加载过程采用父亲（双亲）这种机制能更好地保证Java平台的安全。在此委托机制中，各个加载器按照父子关系形成了逻辑上的树形结构，除了Java虚拟机自带的根类加载器外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则由父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。
2）	若有一个类加载器能成功加载Sample类，那么这个类加载器被称为定义类加载器，所有能成功返回Class对象引用的类加载器（包括定义类加载器）都被称为初始类加载器
13.	类的卸载
1）	当某个类被加载、连接、初始化后，它的生命周期就开始了。当代表这个类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，这个在方法区内的数据也会被卸载，从而结束这个类的生命周期。
2）	一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期
3）	由JVM自带的类加载器加载的类，在虚拟机的生命周期中，始终不会被卸载。JVM本身会始终引用这些类加载器，而这些类加载器始终会引用它们所加载的Class对象，因此这些Class对象始终是可触及的
4）	由用户所定义的类加载器所加载的类是可以被卸载的。
14.	类加载器命名空间
1）	每一个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器加载的类组成。
2）	在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
3）	在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类。
4）	父加载器加载的类看不到子加载器加载的类的Class对象。子可以看到父的。同一个命名空间的类是相互可见的。
5）	在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器（define loader）所共同决定的。如果同样的名字的类是由两个不同的类加载器所加载，那么这些类就是不同的，即使.class文件的字节码完全一样，并且从相同的位置加载亦如此。
6）	在oracle的Hotspot实现中，系统属性sun.boot.class.path如果修改错了，则运行会出错。因为无论要加载什么类，都首先必须加载java.lang.Object类，如果修改错了根类加载器的加载路径，则会寻找不到此类
7）	数组类型不是类加载器加载的，而是在运行期间由JVM动态创建的。
8）	Hotspot 虚拟机所提供的扩展类加载器和系统类加载器是纯Java类，由启动类加载器所加载。启动类加载器是C++代码，内建于JVM中，在JVM启动时就会被实例化或创建相应的启动类加载器对象。
9）	内建于JVM中的启动类加载器会加载java.lang.ClassLoader及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，他会加载扩展类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器（bootstrap）
10）	启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。所有类加载器（除了启动类加载器）都被实现为Java类，不过总归要有一个组件来加载第一个Java类加载器，从而让整个加载过程能够顺利进行下去。加载第一个纯Java类加载器就是启动类加载器的职责。
11）	启动类加载器还会负责加载JRE正常运行所需要的基本组件，包括java.util与java.lang包中的类等。
15.	线程上下文类加载器（Context ClassLoader）
1）	当前类加载器（Current ClassLoader）：
用于加载当前类的加载器。每一个都会使用自己的加载器（即加载自身的类加载器）来去加载它所依赖的类。
例：如果ClassX引用了ClassY，那么ClassX的类加载器就会去加载ClassY，前提是ClassY尚未被加载。
2）	线程上下文类加载器（Context ClassLoader）：
从JDK1.2开始引入的，类Thread中的getContextClassLoader()与setContextClassLoader()分别用来获取和设置上下文加载器。如果没有通过setContextClassLoader()进行设置的话，线程将继承器父线程的上下文加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类与资源
16.	线程上下文类加载器的重要性
1）	SPI（Service Provider Interface）：
由JDK定义接口，实现由厂商自己定义。例如JDBC
此时JDK定义的接口位于Java核心jar中，由启动类加载器进行加载；厂商自己定义的具体实现提供的第三方jar存放在项目的类路径中，由系统类加载器进行加载。
如果依赖于双亲委托机制，则启动类加载的接口无法见到系统类加载器所加载的具体实现类，那么SPI的功能就无法实现
2）	父ClassLoader可以使用当前当前线程
Thread.CurrentThread().getContextClassLoader()所指向的类加载器所加载的类，这就改变了父ClassLoader不能使用子ClassLoader或是其他没有直接父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。
3）	线程上下文类加载器就是当前线程的Current ClassLoader
4）	在双亲委托模型下，类加载器是由下至上的，即下层的类加载器会委托上层的类加载器进行加载。但是对于SPI来说，有些接口是Java核心库所提供的，而Java核心库是由启动类加载来加载的，而这些类的实现却来自于不同的jar包（厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的需求（会出现接口由启动类加载器就那些加载，实现类由系统类加载器进行加载），而通过给当前线程设置上下文类加载器，就可以有设置的上下文类加载器来实现对于接口实现类的加载
17.	线程上下文类加载器的一般使用模式（获取 — 使用 — 还原）
ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
Thread.currentThread().setContextClassLoader(targetClassLoader);
myMethod();
Thread.currentThread().setContextClassLoader(classLoader);

myMethod()里面调用了Thread.currentThread().getContextClassLoader()，获取当前线程上下文类加载器做某些事情
1）	如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载的。ContextClassLoader的作用就是为了破坏Java的类加载委托机制的
2）	当高层提供了统一的接口让低层实现，同时又要在高层加载或实例化低层类时，就必须要通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。
18.	
一、	Java虚拟机与程序的生命周期
1.	在以下几种情况中，Java虚拟机将结束生命周期
1)	执行了System.exit()
2)	程序正常执行结束
3)	程序在执行过生中遇到了异常或错误而异常终止
4)	由于操作系统出现错误而导致Java虚拟机进程终止
2.	类的加载、连接、初始化、使用、卸载（将类从内存中移除）
1）	加载：查找并加载类的二进制数据
2）	连接：
	验证：确保被加载类的正确性
	准备：为类的静态变量分配内存，并将其初始化为默认值
	解析：把类中的符号引用装换为直接引用
在类的常量池中寻找类、接口、字段和方法的符号引用，把这个符号引用替换成直接引用
3）	初始化：为类的静态变量赋予正确的初始值
3.	Java对类的使用方式分为两种，所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们。
1）	主动使用
2）	被动使用
4.	Java对类的主动使用分为（七种）：
1）	创建类的实例
2）	访问某个类或接口的静态变量，或者对该静态变量赋值 
getstatic 
putstatic
3）	调用类的静态方法
invokstatic
4）	反射（Class.forName(“XXX”)）
5）	初始化一个类的子类
初始化一类，会将其所有父类都初始化
6）	Java虚拟机启动时被标明为启动类的类
7）	JDK1.7 开始提供的动态语言支持：
Java.lang.invoke.MethodHandle实例的解析结果
REF_getstatic
REF_putstatic
REF_invkestatic
5.	除了上述七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化
二、	类的加载
1.	类的加载：将类的.class文件中的二进制数据读入内存中，将其放在运行时数据区的方法区（元数据空间）内，然后再内存中创建一个java.lang.Class对象，用来封装类在方法区内的数据结构
2.	加载.class文件的方式
1）	从本地系统中直接加载
2）	通过网络下载
3）	从zip，jar等归档文件中加载
4）	从专有数据库中提取
5）	将Java源文件动态编译为.class文件（1.动态代理有运用到，类在运行期生成，编译时不存在 2.web开发语言中，JSP最终转换成Servlet）
6）	
3.	类实例化的过程
1）	为新的对象分配内存
2）	为实例变量赋予默认值
3）	为实例对象赋予正确的初始值

Java编译器为它编译的每一个类都至少生成一个实例初始化方法，在Java的class文件中，这个实例初始化方法被称为<init>。针对源代码中的每一个类的构造方法，Java编译机都产生一个<init>
4.	
三、	
四、	Jvm参数
1.	Jvm参数
-XX:+<option> 开启option选项
-XX:-<option> 关闭option选项
-XX:<option>=<value> 将option选项的值设置为value

1）-Xms最小堆大小
-Xmx最大堆大小
-Xss 堆栈大小
-XX: MaxMetaspaceSize最大元空间大小  -XX: MaxMetaspaceSiz=10m
-XX:+HeapDumpOnOutOfMemoryError：发生OutOfMemory异常时导出堆转储文件

-Xms5m -Xmx10m –XX:+HeapDumpOnOutOfMemoryError

2.	初始化
1）	对于静态字段来说，只有直接定义了该字段的类才会被初始化
2）	当一个类被初始化时，要求其父类全部都已经初始化完毕了
3）	常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
引用一个类的常量，不会导致定义这个类的常量初始化
4）	当一个常量池并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中。这样在程序运行时，会导致主动使用这个常量所在的类。
5）	对于数组实例来说，其类型是由JVM在运行期间动态生成的，表示为［XXX这种形式。动态生成的类型，其分类型是Object
对于数组来说，JavaDoc经常将构成数组内元素称为Component，实际上就是将数组降低一个维度后的类型。
当创建一个数组类型的实例时，并不表示对数组中元素类型的主动使用。
6）	当一个接口在初始化时，并不要求其父接口都完成了初始化
只有真正使用到父接口的时候（如引用接口中所定义的常量）才会初始化
7）	静态变量的声明语句以及静态代码块的定义语句，都被看作类的初始化语句。JVM会按照初始化语句在类文件中的先后顺序来依次执行他们。
3.	助记符
1）	ldc：将int、float或String类型的常量值从常量池中推送至栈顶（将要用到的）
2）	bipush：将单字节（-127，128）的常量值推送至栈顶
3）	sipush：将一个短整形的常量值推送至栈顶
4）	iconst_1：将int类型的数字1推送至栈顶
只有-1到5使用iconst_N
5）	anewarray：创建一个应用类型的数组，并将其应用值压入栈顶
6）	newarray：创建一个原始类型的数组，并将其应用值压入栈顶
7）	invokeinterface：调用接口的方法，实际上是在运行期决定的， 决定到底调用实现该接口的那个对象的特定方法
8）	invokestatic：调用静态方法
9）	invokesepcial：调用自己的私有方法、构造方法（<init>）以及父类的方法
10）	invokevirtual：调用虚方法，运行期动态查找的过程。
11）	invokedynamic：动态调用方法
4.	

字节码
一、	字节码结构
1.	使用javap –verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类变量与成员变量等信息
1）	魔数：所有.class文件的前4个字节都是魔数，模数值为固定值：0xCAFEBABE
2）	版本信息:魔数之后的4个字节为版本信息，前两个字节表示minor version（次版本号），后两个字节表示major version（主版本号） 2+2
3）	常量池 constant pool 第9个字节开始  2（常量个数）+n个
4）	Access Flags访问标志（当前类的访问标志） 2个字节
5）	This Class Name （当前类名）  2个字节
6）	Super Class Name （父类） 2个字节
7）	Interfaces （类实现的接口） 2（接口个数）+n个字节
8）	Fields （成员变量的信息）  2（成员变量个数）+n个字节
9）	Methods （方法） 2（方法个数）+n个字节
10）	Attributes （当前类的附加属性，例如编译器在编译的时候插入的一些额外的属性）  2+n个字节
2.	常量池（constant pool）：紧接着主版本号之后就是常量池入口。第9个字节开始
1）	一个Java类中定义的很多信息都是有常量池来维护和描述的。可以将常量值看作是Class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池中。
2）	常量池中主要存储两类常量：字面量与符号引用
字面量：如文本字符串，Java中声明为final的常量值等
符号引用：类和接口的全局限定名、字段名称和描述符（如public void int等）、方法的名称和描述符等
3）	常量池的总体结构：Java所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后，占据2个字节；常量池数组则紧跟在常量池数量之后。常量池数组与一般数组的区别：常量池中不同的元素的类型、结构都是不同的，长度当然也就不同。每一种元素的第一个数据都是u1类型，该字节是一个标志位，占据一个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。
4）	常量池数组中元素的个数 = 常量池数 – 1（其中0暂时不使用）。
目的是满足某些常量池索引值的数据在特定情况下需要表达『不引用任何一个常量池』的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量表（常量池数组）中，这个常量就对应null；所以，常量池的索引从1而非0开始。
5）	在JVM规范中，每个变量/字段都有描述信息，描述信息的主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的权限定名来表示（包名与类名之间使用‘/’分隔）。为了压缩字节码文件的体制，对于基本数据类型，JVM都使用一个大写字母来表示。
B：byte
C：char
D：double
F：float
I：int
J：long
Z：boolean
S：short
V：void
L：对象类型  例：Ljava/lang/String 代表String类型
6）	对于数组类型来说，每一个维度使用一个前置的 [ 来表示，如int[]被记录为[I，String[][]被记录为[[Ljava/lang/String
7）	用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组 () 之内。
String getRealNameByIdAndNickName(int id, Stirng name)：(I, Ljava/lang/String) Ljava/lang/String
8）	
3.	Class字节码中有两种数据类型
1）	字节数据直接量：
这是基本的数据类型。共细分为u1、u2、u4、u8四种，分别代表连续的一个字节、2个字节、4个字节、8个字节组成的整体数据
2）	表（数组）：
表是由多个基本数据或其他表，按照既定顺序构成的大的数据集合。表是有结构的，它的结构体现在，组成表的成分所在的位置和顺序都是已经严格定义好的
4.	Access Flags
访问标志信息包括该Class文件是类还是接口，是否被定义成public，是否是abstract，如果是类，是否被声明为final。
5.	Fields
field_info {
u2 access_flag
u2 name_index
u2 descirptor_index
u2 attribute_info attributes[attributes_count]
}
6.	对于Java类中的每一个实例方法（非static方法），其在编译后所生成的字节码当中，方法参数的数量总会比源代码中方法参数的数量多一个（this），它位于方法的第一个参数位置处；这样，我们就可以在Java的实例方法中使用this去访问当前对象的属性以及其他方法。
1）	这个操作是在编译期间完成的，即由javac编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问，接下来在运行期间，由JVM在调用实例方法时，自动向该实例方法传入this参数。所以，实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。
7.	Java字节码对于异常的处理方式
1）	统一采用异常表的方式来对异常进行处理
2）	在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，而是采用特定的指令方式
3）	当异常处理存在finally语句块时，现代化的JVM采取的处理方式是将finally语句块的字节码拼装到每一个catch块后面，换句话说，程序中存在多少个catch块，就会在在每一个catch块后面重复多少个finally块的字节码。
8.	栈帧（stack frame）
1）	栈帧是一种用于帮助虚拟机执行方法调用与方法执行的数据结构，封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈等信息。在Java的整个方法调用的过程中，从调用开始到方法执行完毕，都存在栈帧的入栈和出栈的过程，每个线程都有属于自己的一份栈帧
动态链接：类与类之间的交互关系
符号引用：如被引用类的全局限定名
直接引用：（内存地址，在编译阶段不可知）可以通过直接引用在内存中找到被调用的方法
当一个方法去调用另一个方法时，会往栈中再压入一个栈帧，这个栈帧封装了被调用的目标方法的局部变量表、动态链接、操作数栈、方法返回地址等。
2）	局部变量表：用于存储局部变量。Slot是存储局部变量的最小单位
3）	符号运用存储在Class文件的常量池当中，方法调用就是通过常量池指向方法的符号引用将其作为参数。符号引用在类加载时或第一次使用时转换为直接引用（静态解析）；些符号引用则是在每次运行期转换为直接引用（动态链接），这体现为Java的多态性
4）	静态解析的四种情形（不存在多态的可能，在类加载时就可以唯一确定），称为非虚方法，它们可以在类加载阶段就可以将符号引用转换为直接引用：
	静态方法
	父类方法
	构造方法
	私有方法（无法被重写）
5）	方法的静态分派
Grandpa g1 = new Father();
Grandpa为g1声明类型，也称为g1静态类型
Father为g1所指向的实际类型（真正指向的类型）
	变量本身的静态类型不会被改变的，除了进行强制向下类型转化
	而变量的实际类型是可以发生变化的（多态的一种体现），实际类型在运行期方可确定
	方法重载是一种静态行为，在编译期就可完全确定。根据方法声明的参数类型和变量的静态类型来决定调用哪一个重载方法，而不是根据参数的实际类型来决定。
6）	方法的动态分派
方法的动态分派涉及到一个重要概念：方法接收者。
nvokevirtual字节码指令的多态查找流程：
	到操作数的栈顶去寻找到栈顶的第一个元素所指向对象的实际类型
即invokevirtual指令执行的第一步就是在运行期间确定方法接收者的实际类型
	如果对象的实际类型中特定的方法与常量池中的描述符、名称都相同，且有访问权限的方法，则直接返回目标方法的直接引用
	如果没有找到，则按继承的层次关系，从子类往父类依次对各个父类重复相同的查找流程，直到找到符合特定对象的方法
	如果最后都没有找到，则抛出异常。
7）	比较方法重载（overload）与方法重写（override），我们可以得到这样一个结论：方法重载是静态的，是编译期行为；方法重写是动态的，是运行期行为。
8）	针对于方法调用的动态分派的过程，JVM会在类的方法区建立一个虚方法表的数据结构（virtual method table， vtable）针对于invokeinterface指令来说，JVM会建立一个叫做接口方法表的数据结构（interface method table， itable）
存放每一个方法真正的入口地址
因此针对于多态的查找机制，使用vtable或itable代替了去常量池中查找的过程。
如果是同一个方法，子类和父类的方法在各自的vtable或itable中，索引号都相同。这样可以提高查找效率：子类找到自己的方法后，发现需要真实调用的是父类的方法，则直接按照子类的索引号，去查父类对应索引号的方法即可。反之亦然
9）	虚方法表一般是在类加载的连接阶段完成初始化。

二、	Java中字节码执行
基于栈的执行过程（JVM）：
	缺点：速度较慢；完成相同的操作，需要执行的指令数量更多，在内存中操作，涉及到大量的内存访问，影响执行效率
典型的先进后出的特征，不断地将数据入栈出栈。
	优点：可移植性好

基于寄存器的指令集
	缺点：寄存器本身与硬件如CPU密切相关，不同CPU指令集不相同，不存在移植性的概念。
	在CPU的高速缓冲区中执行，速度更高

1.	现代JVM在执行Java代码时，通常都会将解释执行与编译执行二者结合起来进行。
1）	解析执行：就是通过解析器来读取字节码，遇到相应的指令就去执行该指令
2）	编译执行：就是通过即时编译器（Just In Time， JIT）将字节码转换为本地机器码来执行。现代JVM会根据代码热点（执行频次高的代码）来生成相应的本地机器码
2.	基于栈的指令集与基于寄存器的指令集之间的关系
1）	JVM执行指令时所采取的方式是基于栈的指令集
2）	基于栈的指令集的主要操作有入栈与出栈两种。
3）	基于栈的指令集的优势在于它可以在不同的平台之间进行移植，而基于寄存器的指令集是于硬件架构紧密关联的，无法做到可移植。
4）	基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多；基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快得多。虽然JVM可以采用一些优化手段（将高频的操作映射到寄存器中），但总体来说，基于栈的指令集的执行速度要慢一些。



内存模型

一、	内存空间的基本布局
1.	虚拟机栈：stack frame栈帧，每个方法在执行时都会生成一个栈帧，用于存储局部变量表、操作数栈等数据
1）	线程独有，生命周期与线程相同
2）	局部变量信息，引用类型
2.	程序计数器：program counter，指定下一条指令地址
1）	用于标识当前线程执行的行号或顺序
2）	线程独有，生命周期与线程相同
3）	上一个执行的线程挂起的位置信息
3.	本地方法栈：涉及native方法，作用和结构与stack frame类似。主要用于处理本地方法。
4.	堆：heap，JVM管理的最大一块内存空间。被所有线程共享，虚拟机创建时，堆的内存就会被从操作系统申请下来，用于存放对象实例。
1)	引用本身是一个变量，位于虚拟机栈中（局部变量表的一个局部变量）。真正的对象存放于堆中
2)	对象分为两部分内容
	对象本身真正拥有的数据（如成员变量），存在于堆中。
	对象所属的类型，元数据信息（如类型数据）。同一个类型的对象，拥有同一份元数据信息。存在于方法区中，
3)	引用指向对象的实现方式
	引用指向的不是对象本身，而是指向一个指针。这个指针有两个指向对象实际数据的指针：一个指向对象的数据，一个指向对象的元数据
	引用指向堆中的对象，在堆中存储对象的数据以及一个指向对象元数据的指针
4)	与堆相关的一个重要概念是垃圾收集器。现代几乎所有的垃圾收集器都是采用的分代收集算法。所以，堆空间也基于这一点进行了相应的划分：新生代和老年代
	Eden空间、From Survivor空间和To Survivor空间。

5)	Java的堆空间在内存上既可以是连续的，也可以是连续的

5.	方法区：method area 存储元信息（类型信息）。
1）	永久代：permanent generation。 jdk 1.8开始，彻底废弃了永久代，使用元空间来代替（meta space）。
2）	方法区里的元信息很少会被回收。关于Class的元信息的卸载，卸载后占用的内存就会被回收掉，但是卸载的条件很难满足
6.	运行时常量池：方法区的一部分内容。Class的字节码结构中绝大部分信息是常量信息（字面值和符号引用等）
7.	直接内存：direct memory，不是由JVM管理，而是由操作系统直接管理。JVM可以向OS申请
1）	Java虚拟机外开辟的内存空间，与Java nio直接相关。
2）	Java通过DirectByBuffer来操作直接内存。

二、	Java对象创建的过程
1．	new关键字创建的对象的三个步骤
1）	在堆内存中创建对象的实例
2）	为对象的成员变量赋初值，此时是为成员变量赋初值，静态变量在类加载时已经进行初始化
3）	将对象引用返回

	虚拟机首先检查指令的参数是否能在常量池中定位成一个类的符号引用
	后检查这个类的符号引用所对应的类是否已经被加载、连接、初始化 ，如果没有，则先进行这些操作
	在类加载完成后，为对象分配内存。分配内存可分为两部分：
指针碰撞：如果堆是截然有序的，例左侧为已被占用的空间，右侧为空闲的空间，中间通过一个指针在两者的边界做一个指向，当对象在内存中进行创建时，会在右侧空闲的空间中分配一块内存，指针发生移动，指向下一个可以被使用的空间，这种情况下，称为指针碰撞。
空闲列表：堆是无序的，JVM需要记录一个堆使用列表。对象创建时，JVM从列表中寻找可以容纳新创建对象大小的空间，把新对象放置到这个空间中，并修改列表中的记录，标志这块空间已被使用。

	指针碰撞：前提是堆中的空间通过一个指针进行分割，一侧是已被占用的空间，另一个是未被占用的空间。
	空闲列表：前提是堆内存空间已被使用与未被使用的空间是交织在一起的，这是虚拟机就需要通过一个列表来记录哪些空间是可以使用的，哪些空间是已被使用的。接下来找出可以容纳下新创建对象的且未被使用的空间，在该空间存放该对象，同时还要修改列表上的记录

2．	对象的内存布局
1）	对象头：存储对象自身的运行时信息，如对象的hash码、分代的信息
2）	实例数据（即我们在一个类中所声明的各项数据）
3）	对齐填充（可选）：起占位符的作用
3．	应用访问对象的方式：
1）	使用句柄的方式（引用指向的是指针）
2）	直接指针方式（引用指向的是对象）
4．	jmap、jstat、jcmd、jvisualVM、jmc、jhat、jfr、jconsole可视化工具
1）	jcmd：从jdk1.7开始增加的
	jcmd <pid> VM.flag  查看JVM的启动参数
	jcmd <pid> help  列出当前运行的Java进程可以执行的操作
	jcmd <pid> help <command> 查看具体命令的选项
	jcmd <pid> PerfCounter.print 查看JVM性能相关的参数
	jcmd <pid> VM.uptime 查看JVM的启动时长
	jcmd <pid> GC.class_histogram  查看系统中类的统计信息
	jcmd <pid> GC.heap_dump <fileName> 生成堆转储文件  （后缀名.hprof）
	jcmd <pid> VM.system_properties 查看VM的属性信息
	jcmd <pid> VM.version 查看目标JVM进程的版本信息
	jcmd <pid> VM.command_line 查看JVM启动的命令行参数
2）	jstack  线程堆栈的分析工具，可以查看或导出Java应用程序中线程的堆栈信息
jstack <pid>
 
3）	jmc：Java Mission Control 可视化工具
4）	jfr：Java Flight Recorder  实时获取Java进程或JVM进程的统计数据
5）	jmap
jmap –clstats <pid>  打印类加载器的数据
jmap –heap <pid>  打印Java堆的信息

6）	jstat
jstat –gc <pid> 打印Java堆的信息
7）	jhat命令行工具，进行堆转储文件的分析，类型jvisualvm的功能
运行oql查询语言  对象查询语言
8）	


垃圾回收

一、	JVM运行时内存数据区域
1.	线程共享的
1）	方法区  method area
	类的元数据
	每个类的Class结构信息，包括常量池、字段描述、方法描述等元信息
	GC的非主要工作区域
2）	堆 heap
	主要存放对象，垃圾回收的主要区域
	是Java虚拟机管理内存中最大的一块
	GC工作的主要区域，为了高效的GC，会把堆细分为更多的子区域
2.	线程隔离的
1）	Java虚拟机栈 JVM stack
	方法调用的相关信息、每个方法调用都会产生一个栈帧
	存放局部变量表、操作数栈、动态链接、方法出口等信息。一个方法的执行过程，就是这个方法对于栈帧的入栈和出栈过程
2）	本地方法栈 native method stack
与Java虚拟机栈类似，主要存放本地方法调用的相关信息
3）	程序计数器 program counter register

在Hotspot中本地方法栈和JVM方法栈是同一个，因此也可用 –Xss控制
3.	例
public void method1 () {
    Object obj = new Object()
}

1）	生成2部分的内存区域
	obj这个引用变量，因为是方法内的变量，放到JVM stack中
	真正Object class的实例对象，放到heap中
2）	上述的new语句一共消耗12bytes，JVM规定应用占4bytes（在JVM stack），而空对象是8bytes（在heap）
3）	方法结束后，对应stack中变量马上回收，但是heap中的对象要等到gc来回收
4.	方法区
1）	Java虚拟机规范表示可以不要求虚拟机在这区实现GC，这区的GC“性价比”一般比较低
2）	在堆中，尤其是在新生代，常规应用进行一次GC一般可以回收70%~95%的空间，而方法区的GC效率远小于此
3）	当前的商业JVM都有实现方法区的GC，主要回收两部分内容：废弃常量与无用类
5.	类回收需要满足的条件
1）	该类的所有实例都已经被GC，也就是JVM中不存在改Class的任何实例
2）	加载该类的ClassLoader已经被GC
类加载器与其加载的对象是双向引用的
3）	该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法
4）	在大量使用反射、动态代理、GCLib等字节码框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景都需要JVM具备类卸载的支持以保证方法区不会溢出
5）	
6.	


二、	JVM垃圾回收模型
1.	垃圾判断算法
1）	引用计数算法（reference counting）
	给对象添加一个引用计数器，当有一个地方引用它，计算器加1，当引用失效，计数器减1。任何时刻计数器为0的对象就是不可能再被使用的。
	引用计数算法无法解决对象循环引用的问题
2）	根搜索算法（root tracing）
	通过一系列的称为“GC Roots”的点作为起始开始进行向下搜索，当一个对象到GC Roots没有任何引用链（Reference Chain）相连，则证明此对象是不可用的
3）	GC Roots
	在VM栈（Java虚拟机栈帧中的本地变量）中的引用
	方法区的静态变量
	JNI（即一般说的Native方法）中的引用
4）	
2.	GC算法
1）	标记-清除算法（Mark-Sweep）

2）	标记-整理（压缩）算法（Mark-Compact）
3）	复制算法（Copying）
4）	分代算法（Generational）
3.	垃圾回收器的实现和选择
4.	标记-清除算法（Mark-sweep）
1）	算法分为“标记”和“清除”两个阶段。首先标记出所有需要回收的对象，然后回收所有需要回收的对象
2）	缺点：
	效率问题，标记和清理两个过程效率都不高。需要扫描所有对象，堆越大，GC越慢
	空间问题，标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜索动作。存在内存碎片问题。GC次数越多，碎片越严重。

5.	复制（copying）搜集算法
1）	将可用内存区域分为两块，每次只是用其中的一块，当半区内存用完了，仅将还存活的对象复制到另一块上面，然后把整块内存空间一次性清理掉
2）	这样使得每次内存回收都是堆整个半区的回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存就可以了，实现简单，运行高效。
3）	缺点
	这种算法的代价是将内存缩小为原来的一半，代价高昂
	复制收集算法在对象存活率较高的时候，效率有所下降
	如果不想浪费50%的空间，就需要额外的空间进行分配担保使用应付半区内存中所有对象都100%存活的极端情况，所以在老年代一般不能使用这种算法
4）	现代的商业虚拟机中都是使用了这一种收集算法来回收新生代
	新生代：刚创建出来的对象都位于新生代中
	将内存分为1块较大的eden空间和2块较小的survivor空间，，每次使用Eden和其中一块survivor，当回收时将eden和survivor（（from））还存活的对象一次性拷贝到另外一块survivor（to）空间上，然后清理掉eden和用过的survivor
	Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存空间是“浪费”的。
5）	复制收集算法在对象存活率较高的时候，效率有所下降
6）	复制（copying）收集算法特点
	只需要扫描存活的对象，效率更高
	不会产生碎片
	需要浪费额外的内存作为复制区
	复制算法非常适合存活周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小
	根据IBM的专门研究，98%的Java对象只会存活1个GC周期，对这些对象很适合用复制算法。而且不用1:1划分工作区和复制区的空间
6.	标记-整理（Mark-compact）算法
1）	标记过程任然一样，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存
2）	特点
	没有内存碎片
	比mark-sweep耗费更多的时间进行compact
	
7.	分代收集（Generational Collecting）算法
1）	当代商业虚拟机的垃圾收集都是采用“分代收集”（Generational Collecting）算法，根据对象不同的存活周期将内存划分为几块。
2）	一般是把Java堆分作新生代和老年代，这样就可以根据各个年代得特点采用最适当的收集算法。譬如新生代每次GC都有大批对象死去，只有少量存活，那就选用复制算法只需要付出少量存活对象的复制成本就可以完成收集
3）	年轻代
	新生成的对象都放在年轻代（并且只会生成在eden区中，除了巨型对象可能直接会在老年代分配）。年轻代用复制算法进行GC（理论上，年轻代对象的生命周期非常短，所以适合复制算法）
	年轻代分为三个区，一个eden区，两个survivor区（可以通过参数设置survivor个数）。对象在eden区中生成，当eden区满时，还存活的对象将被复制到另一个survivor去，当这个survivor区满时，此区的存活对象将被复制到另一个survivor区，当第二个survivor区也满了的时候，从第一个survivor区复制过来的并且此时还存活的对象，将被复制到老年代。2个survivor是完全对称，轮流替换。
	Eden和；两个survivor的缺省比例是8:1:1，也就是10%的空间会被浪费。可以根据GC log的信息调整大小比例
	在新生代中，一个新创建的对象在eden空间当中生成的，接下来如果发生垃圾收集的话，会将eden区和from区还存活的对象都复制到to空间中，再将eden和from空间清空，同时from和to的角色发生变化，from变成to，to变成from
4）	老年代
	存放经过一次GC或多次GC还存活的对象
	一般采用mark-sweep或mark-compact算法进行GC
	有多种垃圾收集器可以选择。每种垃圾收集器可以看作一个GC算法的具体实现。可以根据具体应用的需求选用合适的垃圾收集器
	老年代并不属于堆（heap），但是GC也会涉及到这个区域
	存放了每个Class的结构信息，包括常量池、字段描述、方法描述。与垃圾收集要收集的Java对象关系不大
5）	
8.	针对不同生命周期的对象采用不同的GC算法 
9.	内存分配
1）	堆上分配
	大多数情况在eden上分配，偶尔会直接在old上分配。
	细节取决于GC的实现
2）	栈上分配
	原子类型的局部变量
	引用
3）	
10.	内存回收
1）	GC要做的是将那些dead的对象所占用的内存回收掉
	Hotspot认为没有引用的对象是dead的
2）	Hotspot将引用分为四种：Strong 强引用、Soft软引用、Weak 弱引用、Phantom 虚引用
	Strong即默认通过 Object o = new Object()这种方式赋值的引用
	Soft、Weak、Phantom这三种则都是继承于Reference
3）	在进行Full GC回收时，会对Reference类型的引用进行特殊处理
	Soft：内存不够时一定会被GC，长期不用也会被GC
	Weak：一定会被GC，当被mark为dead，会在ReferenceQueue中通知
	Phantom：本来就没引用，当从jvm heap中释放时会通知
11.	垃圾收集算法
1）	新生代：
	Serial
	ParNew
	Parallel Scavenge
	
2）	老年代：
	CMS
	Serial Old（MSC）
	Parallel Old
12.	GC的时机
1）	在分代模型的基础上，GC从时机上分为两种：Scavenge GC和Full GC
2）	Scavenge （清理）GC （Minor GC）
	触发时机：新对象生成时，eden空间满了
	理论上eden区大多数对象会在Scavenge GC回收，复制算法的执行效率会很高，Scavenge GC时间比较短
3）	Full GC
	对整个JVM进行整理，包括young（新生代）、old（老年代）和perm（永久代）
	主要的触发时机
Old满了
Perm满了
System.gc()
	效率很低，尽量减少 Full GC
13.	垃圾回收器（Garbage  Collector）
1）	分代模型：GC的宏观愿景
2）	垃圾回收器：GC的具体实现
3）	Hotspot JVM 提供 多种垃圾回收器，我们需要根据具体应用的需求采用不同的回收器
4）	没有万能的垃圾回收器，每种垃圾回收器都有自己的适用场景
14.	垃圾收集器的“并行”和“并发”
1）	并行（parallel）
指多个垃圾收集器的线程同时工作，但是用户线程处于等待状态
2）	并发（Concurrent）
	收集器在工作的同时，可以允许用户线程工作
	并发并不是解决了GC停顿的问题，在关键步骤还是要停顿的。比如在收集器标记垃圾的时候。但在清除垃圾的时候，用户线程可以和GC线程并发执行
15.	Serial收集器
1）	单线程收集器
2）	收集时会暂停所有工作线程（Stop The World，简称STW），使用复制收集算法，虚拟机运行在Client模式时默认新生代收集器
3）	特点
	最早的收集器
	New和Old Generation都可以使用
	在新生代，采用复制算法，暂停所有用户的线程；在老年代，采用mark-compact算法，暂停所有用户的线程
	因为是单线程GC，没有多线程切换的额外开销，简单实用
	Hotspot Client模式缺省的收集器
16.	ParNew收集器
1）	ParNew收集器就是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Serial收集器一模一样
2）	对应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单核的环境中，ParNew收集器并不会比Serial收集器有更好的效果
3）	特点
	Serial收集器在新生代的多线程版本
	使用复制算法（因为针对新生代）
	只有在多CPU的环境下，效率才会比Serial收集器高
	可以通过 –XX:ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数
	Server模式下新生代缺省收集器
17.	Parallel Scavenge收集器
1）	一个多线程收集器
2）	使用复制算法，但是它的对象分配规则、回收策略都与ParNew收集器有所不同，它是以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化
18.	Serial Old收集器（STW）
1）	单线程收集器
2）	使用标记-整理算法
3）	是老年代的收集器
19.	Parallel Old收集器
1）	老年代版本吞吐量优先收集器
2）	使用多线程和标记-整理算法
3）	JVM 1.6提供，在此之前，新生代使用了PS收集器的话，老年代除了Serial Old外别无选择，因为PS无法与CMS收集器配合工作
4）	特点
	Parallel Scavenge 在老年代的实现
	在JVM 1.6才出现Parallel Old
	采用多线程、Mark-Compact算法
	更注重吞吐量
	Parallel Scavenge + Parallel Old = 高吞吐量，但是GC停顿可能不理想
20.	CMS（Concurrent Mark Sweep）收集器  老年代的收集器
1）	CMS是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间。
2）	CMS收集器使用标记-清除算法。
3）	特点：
	追求最短停顿时间，非常适合Web应用
	只针对老年区，一般结合ParNew使用
	Concurrent，GC线程和用户线程并发工作（尽量并发）
	Mark-Sweep
	只有在多CPU环境下才有意义
	使用 –XX:+UseConcMarkSweepGC打开
4）	缺点
	CMS以牺牲CPU资源的代价来减少用户线程的停顿。当CPU个数少于4的时候，有可能对吞吐量影响非常大
	CMS在并发清理的过程中，用户线程还在跑。这时候需要预留一部分空间给用户线程
	CMS用Mark-Sweep，会带来碎片问题。碎片过多的时候会容易频繁触发Full GC
	CMS也会产生浮动垃圾
21.	
三、	内存泄漏
1.	Java内存泄漏的经典原因
1）	对象定义在错误的范围内（Wrong Scope）
2）	异常（Exception）处理不当（如：出现异常时，打开的资源未进行关闭）
3）	集合数据管理不当
	当使用Array-based的数据结构（ArrayList、hashmap等）时，尽量减少resize。减少resize可以比肩没有必要的array copying、gc碎片等问题
	如果一个List只需要顺序访问，不需要随机访问（Random Access），用LinkedList代替ArrayList
LinkedList本质是链表，不需要resize，但适用于顺序访问。
	
4）	
2.	
四、	启动参数
1.	启动参数
1）	-verbose:gc 详细输出JVM中GC的日志
2）	-Xms20M  设置堆初始大小 20m 堆分为新生代和老年代
-Xmx20M 设置堆的最大大小 20m
-Xmn10m 设置堆中新生代的大小为10m
两个参数设置为一样表示JVM在执行GC后不会产生内存的抖动问题
3）	-XX:+PrintGCDetails 打印gc的详细参数
4）	-XX:SurvivorRatio=8  设置eden空间与survivor空间的比例为8:1
如果新生代为10m，则eden空间8m，两个survivor各1m
5）	-XX:PretenureSizeThreshold=4194304   4*1024*1024 设置对象超过多大时直接在老年代进行分配
	以字节为单位，设置当要创建的对象的大小超过这个参数值时，这个对象就不会在新生代进行创建，而是直接在老年代进行内存分配，即使新生代的容量足够
	必须要搭配串行gc收集器才能生效
-XX:+UseSerialGC
 
	tenured generation 老年代used 5120k即 5*1024*1024 正好是对象1的大小
6）	-XX:+PrintCommanLineFlags –version ：打印出当前jvm的版本号，同时打印出jvm默认的启动参数
-XX:InitialHeapSize=2147483648 -XX:MaxHeapSize=32210157568 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC
 
	-XX:InitialHeapSize 初始的堆大小
	-XX:MaxHeapSize=32210157568 最大的堆大小
	-XX:+UseCompressedClassPointers：使用压缩的类指针
	-XX:+UseCompressedOops：从32位的jvm迁移到64位的jvm上时，指针会进行膨胀（32位os的寻址空间与64位os的寻址空间不同，64位的寻址空间更大一些。如果一个程序在32位jvm上运行没有问题时，把其迁移到64位jvm上，因为寻址空间变大，导致指针也会跟着变大，因此指针占据的地址空间也会变大，形成迁移后程序凭空多占了更多的内存空间。）加了这个启动参数可对特定种类的指针进行压缩，使其不再占用更多的内存空间。
	-XX:+UseParallelGC：决定新生代和老年代使用了parallel收集器
新生代使用：parallel scavenge
老年代使用：parallel old
	
7）	-XX:+MaxTenuringThreshold=5  对象在新生代存活的阈值
	设置可以晋升到老年代的最大存活年龄
	在可自动调节对象晋升（Promote）到老年代阈值的GC中，设置该阈值的最大值。由JVM判断何时进入老年代（有一些对象可能年龄为2就会进入老年代）。但是所有对象的年龄在大于5的时候都会被晋升到老年代，最大值为5
	当一个对象在新生代经历过一次minor gc后，它的对象年龄可以认为+1，初始为0。当它又经历了一次gc后，仍然没有被回收，则其年龄再+1，变成2.如果当这个对象的年龄变成6 （>5），则这个对象就会从新生代晋升到老年代
	该参数的默认值为15。CMS默认值为6，G1默认值为5（在JVM中，该数值由4bit来表示，所以最大值1111，即15）
	在新生代经历了多次gc后，存活的对象会在From Survivor与To Survivor之间来回存放，而这里面的前提是这两个空间有足够的大小来存放这些数据。在gc算法中，会计算每个对象年龄的大小，如果达到某个年龄后发现总大小已经大于了survivor空间的50%，那么这时候就需要调整阈值，不能再继续等到默认的15次gc后才完成晋升，因为这样会导致survivor空间的不足，所以需要调整阈值让这些存活对象尽快完成晋升。
8）	-XX:+PrintTenuringDistribution
打印各个年龄段对象所占用的内存大小
9）	+XX:TargetSurvivorRatio=60
	对survivor空间进行设置
	当某一个survivor空间中还存活的对象占据本survivor空间的60%时，会重新计算对象存活的阈值，而不会使用之前显式配置（MaxTenuringThreshold）的值
	
10）	-XX:+PrintGCDateStamps 打印执行gc的时间戳（UTC）
11）	
2.	GC日志解读
 
 

1）	[GC (Allocation Failure) [PSYoungGen: 6409K->792K(9216K)] 6409K->4896K(19456K), 0.0394819 secs] [Times: user=0.08 sys=0.00, real=0.05 secs]

	GC的原因：Allocation Failure 触发时机：新对象生成时，eden空间满了
	GC：Scavenge gc 或minor gc
	[PSYoungGen: 6409K->792K(9216K)]   
PS:paralle scavenge 收集器
YoungGen：年轻代
6409K：GC前年轻代已被占用的空间
792K：GC后年前带已被占用的空间
9216K：新生代的总容量  9m（eden 8m + survivor 1m）
	PS:paralle scavenge 收集器
	6409K->4896K(19456K)
6409K：GC前堆已被占用的空间
4896K：GC后堆已被占用的空间
19456K：堆的总容量  19m
	0.0394819 secs 本次gc所占用的时间
	[Times: user=0.08 sys=0.00, real=0.05 secs]
user=0.08：本次gc在用户空间执行0.08s
sys=0.00：本次gc在系统内核空间执行0s
real=0.05：本次gc实际执行时间0.05s
2）	ParOldGen total 10240K, used 4104K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
	ParOldGen：Par：Parallel Old收集器          OldGen老年代
本次gc新生代释放的空间 6409K-792K=5617k
本次gc总的堆空间释放的空间 6409K-4896K=1513k
本次gc从新生代晋升到老年代的容量5617k-1513k=4104k
	
3）	新生代释放的空间来自两个方面
	对象真的被回收掉
	对象没有被回收掉，晋升到老年代，释放了新生代的空间
4）	GC只涉及到YoungGen的垃圾回收
5）	因为没有指定垃圾收集器，因此使用默认的垃圾收集器
Jdk 1.8默认使用
新生代使用：parallel scavenge
老年代使用：parallel old
6）	
3.	Full GC 日志分析
 
 

1）	[Full GC (Ergonomics) [PSYoungGen: 7171K->2718K(9216K)] [ParOldGen: 8200K->8193K(10240K)] 15371K->10912K(19456K), [Metaspace: 3439K->3439K(1056768K)], 0.0038824 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
	Full gc的原因：Ergonomics 
	出现的结果会造成业务线程暂停：日志打印中，gc结束后才打印
2）	Full GC会涉及到PSYoungGen、ParOldGen、Metaspace的垃圾回收

3）	Full gc会造成STW，因此在日常开发中应尽量避免full gc

4）	当新生代已经无法容纳一个即将进行新创建的对象时，这个对象会直接在老年代诞生
 
	1 2 3 对象占据的空间一共7m，这三个对象是可能可以在eden中进行分配的（因为程序运行时，其他jvm内置的对象也会占用）
	1 2 3 4 对象的存活范围都在main线程中，main线程结束它们的生命周期才会终止，所以gc是无法回收他们的
	4对象因为eden的空间就只有8m，前面三个对象已经占用7m，这个对象无论如何都无法在eden中进行分配
	因此4 对象直接在老年代诞生
	此时只会触发GC，不会触发Full GC
 
	
5）	-XX:+MaxTenuringThreshold=5   设置对象在晋升到老年代之前存活的最大年龄
 
	Desired survivor size 1048576 bytes, new threshold 5 (max 5)
new threshold 5 :本次计算出来的阈值
max 5：最大的阈值
	Desired survivor size 1048576 bytes 所需的survivor空间大小1m             104576/1024/1024=1m
	
 
 
-verbose:gc -Xmx200M -Xmn50M -XX:TargetSurvivorRatio=60 -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:MaxTenuringThreshold=3

	Desired survivor size 3145728 bytes, new threshold 3 (max 3)
3145728/1024/1024 = 3m
所需的survivor空间大小为3m，超过3m需要重新计算新生代存活的阈值
新生代设置为50，则按照默认8:1:1，则survivor空间为5m， 5*60%=3m
	
6）	
4.	新生代采用复制算法，老年代采用标记-整理或标记-清除算法的原因

从两个方面回答：根据对象本身生命周期的特点决定的，对于新生代来说，里面的对象大部分都是朝生夕没的，复制的代价不太高；新生代采用复制算法还有一个原因是新生代由分配担保的机制，将eden和from survivor中存活的对象复制到 to survivor，但是to survivor装不下时，老年代就作为这个复制策略的分配担保的方式来吧存活时间比较久并且还依然存活的对象晋升到老年代中。老年代缺乏分配担保的策略来去解决这种情况。


对于Java来说，大多数对象存活时间一般较短（朝生夕灭），所以很快这些对象就会被判定为垃圾了。而绝大多数对象创建时在新生代进行创建，这些对象经过很短暂的时间就可能被判定为垃圾，所以每一次在进行垃圾回收的时候，只有少部分的对象依然存活，采用复制算法是比较高效的。
老年代里的对象大多数都是经历过多次垃圾回收依然存活的对象，它们的存活时间比较长，可能大多数对象在上一次垃圾回收到下一次垃圾回收还是存活的，在老年代如果采用复制算法，要产生的复制成本会很高。
在某些极端的情况下，经过几轮垃圾回收后，还有很多对象处于存活的状态，此时当将对象从eden、from空间转移到to空间时，发现to空间不足的情况，此时因为老年代有分配担保的机制，此时可以将一部分存活的对象转移到老年代当中
老年代要采用复制算法，势必也要有一个分配担保的机制，可是老年代后面没有更老的年代可以为其做这个功能。
如果老年代采用复制算法，可能会出现很多对象依然存活，但是to空间此时容纳不行，但是又没有分配担保的机制，此时整个算法就失败了。

标记-清除会产生内存碎片
标记整理：在标记后，将还存活的对象都移动到内存的同一端，耗费更多的时间在对象的移动上
复制算法势必会有部分的内存空间被浪费掉

五、	CMS（Concurrent Mark Sweep）垃圾收集器
判断对象是否存活的方法：引用计数算法和根搜索算法（GC Roots）

1.	枚举根节点
1）	当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知那些地方存放着对象引用。在Hotspot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的。
2.	安全点
1）	在OopMap的协助下，Hotspot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得更高
2）	实际上，Hotspot并没有为每条指令都生成OopMap，而只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能开始暂停。
3）	Safepoint的选定既不能太少以至于让GC等待的时间太长，也不能过于频繁以至于多分增大运行时的负载。所以，安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间非常短暂，程序不太可能因为指令流长度太长这个原因而长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint
4）	对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近额安全点上再停顿下来：抢占式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）
	抢占式中断（Preemptive Suspension）
它不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程都全部中断，如果有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。
	主动式中断（Voluntary Suspension）
当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点时重合的，另外再加上创建对象需要分配内存的地方。
什么时候才主动去轮询（程序执行到安全点的时候，发现标记为真时暂停，否则继续执行）
	
5）	现在几乎没有虚拟机采用抢占式中断来暂停线程从而响应GC事件
	因为GC事件发生时很大概率大多数线程都不在安全点上，这时候先暂停线程，然后恢复线程，让其跑到安全点上也是很消耗时间和资源的行为
	主动式中断由于轮询的地方和安全点是重合的，因此轮询发现标志为真时线程就可以立即自己中断自己
同时在创建对象需要分配内存的地方线程也要进行中断标志轮询
	GC在创建对象需要分配内存的地方才会发生，除非是主动调用System.gc()
3.	安全区域
1）	在使用了Safepoint似乎已经完美地解决了如何进入GC的问题，但实际上情况却不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint，但如果程序在“不执行”的时候呢？所谓程序不执行就是没有分配CPU时间，典型的例子就是处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，JVM也显然不太可能等待线程重新分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决了。
2）	在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。
3）	因为在进行GC时需要进行STW（让业务线程暂停下来），但不是在任何时刻都可以随意让业务线程暂停，安全点和安全区域就是为了解决何时让业务线程暂停以便进入GC收集器进行GC的处理或进行枚举根节点
4.	CMS收集器特点
1）	CMS收集器，以获得最短回收停顿时间为目标，多数应用于互联网站或者B/S系统的服务器端上
Concurrent：并发，描述垃圾收集的线程可以和用户的业务线程同时进行，只是在某一些阶段可以如此
2）	CMS是基于“标记-清除”算法实现的，整个过程分为四个步骤
	初始标记（CMS initial mark）STW
	并发标记（CMS concurrent mark）
	重新标记（CMS remark） STW
	并发清除（CMS concurrent sweep）
3）	CMS实现步骤说明
	其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”
	初始标记只是标记一下GC Roots能直关联的对象，速度很快
（只找GC Roots直接关联的最开始的那个对象，并不会沿着GC Roots的链一直往下找）
	并发标记就是进行GC Roots Tracing的过程，并不会阻碍业务线程的执行
从GC Roots开始，找到被GC Roots关联或引用的对象，接着从这个对象出发，向后面去寻找它能引用或关联到的所有其他对象
	重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，单元比并发标记的时间短。
在并发标记的节点，可能随着业务线程的执行，之前被标记为被引用的对象已经没有再被引用了，反之亦然                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
	
4）	在整个过程中，耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，从总体上看，CMS收集器的内存回收过程是与用户线程一起并发执行的。
5）	CMS优点
	并发收集、低停顿。Oracle公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）
	
6）	CMS缺点
	CMS收集器对于CPU资源非常敏感
	CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次 full gc的产生。如果在应用中国老年代增长不是太快，可以适当调高参数 –XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获得更好的性能。要是CMS运行的期间预留的内存无法满足程序需要时，虚拟机将启动后备预案，临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿的时间就很长了。所以说参数–XX:CMSInitiatingOccupancyFraction设置的太高很容易导致大流量“Concurrent Mode Failure”失败，性能反而降低
	收集结束时会有大量空间碎片产生，空间碎片过多时，将会给大对象的分配带来很大的麻烦，往往出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前进行一次full gc。CMS收集器提供了一个 –XX:+UseCMXCompactAtFullCollection 开关参数（默认就是开启的），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。
5.	空间分配担保
1）	在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。当大量对象在Minor GC后仍然存活，就需要老年代进行空间分配担保，把Survivor无法容纳的对象直接进入老年代。如果老年代判断剩余空间不足（根据以往每一次回收晋升老年代对象容量的平均值作为经验值），则进行一次Full GC。
6.	CMS收集器细分成七个步骤
1）	Initial Mark 初始标记
	这个是CMS两次STW事件的其中一次
	这个阶段的目标是：标记那些直接被GC Roots引用或者被年轻代存活对象所引用的所有对象
2）	Concurrent Mark 并发标记
	在这个阶段收集器会遍历老年代，然后标记所有存活的对象。它会根据上个阶段找到的GC Roots遍历查找。
	并发标记阶段，它会与用户的应用程序并发运行。并不是老年代所有的存活对象都会被标记，因为在标记期间用户的程序可能会改变一些引用
3）	Concurrent Preclean 并发的预先清理
	这也是一个并发阶段，与应用的线程并发运行，并不会stop应用的线程。在并发运行的过程中，一些对象的引用可能会发生变化，但是这个情况发生时，JVM会将包含这个对象的区域（Card）标记为Dirty，这也就是Card Marking
	在pre-clean阶段，那些能够从Dirty对象到达的对象也会被标记，这个标记做完后，dirty card标记就会被清除了
4）	Concurrent Abortable Preclean 并发的可失败的预先清理
	这也是一个并发阶段，同样不会影响用户的应用线程。这个阶段是为了尽量承担STW中最终标记阶段的工作。
	这个阶段持续的时间依赖于很多因素，由于这个阶段是在重复做很多相同的工作、直接满足一些条件（如：重复迭代的次数、完成的工作量或者是时钟时间等）
	目的是为了减少最终标记中STW的时间长度
5）	Final Remark 最终的重新标记
	这是第二个STW阶段，也是CMS中的最后一个。
	这个阶段的目标是标记老年代所有的存活对象，由于之前的阶段是并发执行的，gc线程可能跟不上应用程序的变化，为了完成标记老年代的所有存活对象的目标，STW就十分有必要了。
	通常CMS的Final Remark阶段会在年轻代尽可能干净的视乎运行，目的是为了减少连续STW发生的可能性（年轻代存活对象过多的话，也会导致老年代涉及的存活对象会很多）。这个阶段会比前面几个阶段更复杂一些
经历过以上五个阶段后，老年代所有存活的对象都被标记过了，现在可以通过清除算法去清理那些老年代不再使用的对象
6）	Concurrent Sweep
	这里不需要STW，它是与用户的应用程序并发运行。
	这个阶段的工作是：清除那些不再使用的对象，回收它们的占用空间为将来使用
7）	Concurrent Reset
	这个阶段也是并发执行的，它会重设CMS内部的数据结构，为下次GC做准备。
7.	CMS总结
1）	CMS通过将大量工作分散到并发处理阶段来减少STW时间，在这块做得非常优秀。但是CMS也有一些其他的问题。
	CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生，可能引发串行Full GC
	空间碎片，导致无法分配大对象。CMS收集器提供了一个–XX:+UseCMXCompactAtFullCollection开关参数（默认是开启的），用于在CMS顶不住要进行Full GC时开启内存碎片的合并整理的过程，内存整理的过程是无法并发的，空间碎片没有了，但停顿时间不得不变长
	对于堆比较大的应用，GC的时间难以估计
2）	
	GC (CMS Initial Mark) [1 CMS-initial-mark: 8915K(10240K)] 13080K(19456K), 0.0001364 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [CMS-concurrent-mark-start]
8915K(10240K)  8915K：老年代存活对象占用空间 10240K：老年代总空间
13080K(19456K)  13080K：堆已使用空间 19456K：堆总大小
	[GC (CMS Final Remark) [YG occupancy: 6453 K (9216 K)][Rescan (parallel) , 0.0013902 secs][weak refs processing, 0.0000072 secs][class unloading, 0.0002767 secs][scrub symbol table, 0.0004798 secs][scrub string table, 0.0001178 secs][1 CMS-remark: 8915K(10240K)] 15368K(19456K), 0.0023288 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
YG occupancy: 6453 K (9216 K)  6453 K：年轻代占用空间，9216 K：年轻代总空间
Rescan (parallel) 重新进行扫描
weak refs processing 对弱引用进行处理
class unloading 类卸载
crub symbol table 符号表处理
	
 
[GC (CMS Initial Mark) [1 CMS-initial-mark: 8915K(10240K)] 13080K(19456K), 0.0001364 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-mark-start]
3333333
4444444
[CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-preclean-start]
[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-abortable-preclean-start]
[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (CMS Final Remark) [YG occupancy: 6453 K (9216 K)][Rescan (parallel) , 0.0013902 secs][weak refs processing, 0.0000072 secs][class unloading, 0.0002767 secs][scrub symbol table, 0.0004798 secs][scrub string table, 0.0001178 secs][1 CMS-remark: 8915K(10240K)] 15368K(19456K), 0.0023288 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-sweep-start]
3）	
8.	



六、	G1（Garbage First Collector）收集器
1． 吞吐量
1）	吞吐量关注的是，在一个指定时间内，最大化一个应用的工作量
2）	如下方式来衡量一个系统吞吐量的好坏
	在一个小时内同一个事务（或者任务、请求）完成的次数（tps）
	数据库一个小时可以完成多少次查询（qps）
3）	对于关注吞吐量的系统，卡顿是可以接收的，因为这个系统关注长时间的大量任务的执行能力，单次快速的响应并不值得考虑
2． 响应能力
1）	响应能力指一个程序或者系统对请求是否能够及时响应，比如
	一个桌面UI能多快响应一个事件
	一个网站能够多快返回一个页面请求
	数据库能够多快返回查询数据
2）	对于这类响应能力敏感的场景，长时间的停顿是无法接受的
3． G1（Garbage First Collector）收集器
1）	g1收集器是一个面向服务端的垃圾收集器，适用于多核处理器、大内存容量的服务端系统
2）	它满足短时间dc停顿的同时达到一个较高的吞吐量
3）	JDK 7以上版本使用
4）	与应用线程同时工作，几乎不需要STW（与CMS类似）
5）	整理剩余空间，不产生内存碎片（CMS只能在full gc时，用STW整理内存碎片）
6）	gc停顿更加可控
7）	不牺牲系统的吞吐量
8）	gc不要求额外的内存空间（CMS需要预留空间存储浮动垃圾）
4． G1的设计规划是要替换掉CMS
1）	G1在某些方面弥补了CMS的不足，比如，CMS使用的是Mark-Sweep算法，自然会产生内存碎片，而g1基于copying算法，高效地整理剩余内存，而不需要整理内存 碎片
2）	另外，g1提供了更多手段，以达到对gc停顿时间的可控。
5． G1特点
1）	heap被划分为一个个相等的不连续的内存区域（regions），每个region都有一个分代角色：eden、survivor、old
2）	对每个角色的数量并没有强制的限定，也就是说对每种分代内存的大小，可以动态变化
3）	G1最大的特点就是高效地执行回收，优先去执行那些大量对象可回收的区域（region）
4）	G1使用了gc停顿可预测的模型，来满足用户设定的gc停顿时间。根据用户设定的时间，g1会自动地选择那些region要清除，一次清除多少个region
5）	G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存（copying收集算法）
6）	G1 是在points-out的card table之上再加了一层结构来构成point-into RSet：每个region都会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card范围内 。
7）	这个RSet其实是一个hash table，key是别的region的其实地址，value是一个集合，里面的元素是card table的index。
举例来说，如果region A的RSet例有一项的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对region A来说，该RSet记录的是points-info的关系；而card table仍然记录了该points-out的关系
8）	
6． G1 vs CMS
1）	对比使用Mark-Sweep的CMS，g1使用的copying算法不会造成内存碎片
2）	对比Parallel Scavenge（基于copying）、Parallel Old收集器（基于mark-compact-sweep），Parallel会对整个区域做整理导致gc停顿时间会比较长，而g1只是特定地整理几个region
3）	G1并非一个实时的收集器，与parallel scavenge一样，对gc停顿时间的设置并会绝对生效，只是g1有较高的几率保证不超过设定的gc停顿时间。与之前的gc收集器对比，g1会根据用户设定的gc停顿时间智能评估那几个region需要被回收可以满足用户的设定。
7． G1重要概念
1）	分区（region）：g1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题——g1将整个堆分成相同大小的分区（region）
	每个分区都可能是年轻代也可以是老年代，但是在同一时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑
	在物理上不需要连续，则带来了额外的好处——有的分区内垃圾对象特别多，有的分区内垃圾对象很少，g1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾，这也就是g1名字的由来，即首先收集垃圾最多的分区
	依然是在新生代满了的时候，对整个新生代进行回收——整个新生代中的对象，要么被回收、要么晋升。至于新生代也采取分区机制的原因，则是因为这样跟老年代的策略统一，方便调整代的大小
	G1还是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区拷贝到另一个分区，这个拷贝的过程就实现了局部的压缩
2）	收集集合（CSet）
	一组可被回收的分区共同构成的集合
	在CSet中存活的数据会在gc过程中被移动到另一个可用分区，CSet中的分区可以来自eden空间、survivor空间或者老年代。
	YGC时，CSet里全部都是新生代的region；Mixed GC时，既有新生代里的region，也有老年代里在global concurrent marking时标记出来的收益比最高的部分region
3）	记忆集合（RSet，底层是散列表）
	RSet记录了其他region中的对象引用本region中对象的关系，属于points-into结构（谁引用了我的对象）。
	RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。
4）	Snapshot-At-Beginning（SATB）起始处的快照
	SATB是g1在并发标记阶段使用的增量式的标记算法。
	并发标记是并发多线程的，但并发线程在同一时刻只扫描一个分区
	使用SATB配合三色标记算法就能极大程度上解决我们在标记过程中的出现的漏标和误标的这两种情况
5）	
8． G1 GC的模式
1）	G1提供了两种gc的模式，Young GC和Mixed GC
2）	Young GC：
	选定所有年轻代里的region
	通过控制年轻代里region个数，即年轻代内存大小，来控制Young GC的时间开销
3）	Mixed GC  混合GC：
	选定所有年轻代里的region（即Mixed GC的范围已经涵盖了YGC），外加根据global concurrent marking（全局并发标记）统计得出收集收益高的若干老年代region
	在用户指定的开销目标范围内尽可能选择收益高的老年代region
4）	Mixed GC不是full gc，它只是回收部分老年代的region，如果Mixed GC是在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（Full GC）来收集整个GC heap。所以本质上，G1是不提供full gc。
9． global concurrent marking，介于YGC和Mixed GC之间的阶段。
1）	global concurrent marking的执行过程类似于CMS，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的必须环节。
2）	global concurrent marking的执行过程分为四个步骤
	初始标记（initial mark， STW）:它标记了从GC Roots开始直接可达的对象
	并发标记（Concurrent marking）：这个阶段从GC Roots开始对heap中的对象进行标记，标记线程与应用程序线程并发执行，并且收集各个region的存活对象信息
	重新标记（Remark， STW）：标记那些在并发标记阶段发生变化的对象，将被回收
	清理（Cleanup）：清除空region（没有存活对象的），加入到free list（空闲列表）
3）	第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随着Young GC而发生的。
4）	第四阶段Cleanup只是回收了没有存活对象的region，所以它并不需要STW
10． G1在运行过程中的主要模式
1）	YGC（Young GC）（不同于CMS，CMS无法使用于新生代）
	G1 YGC在eden充满时触发，在回收之后所有之前属于eden的区块全部变成空白，即不属于任何一个分区（eden、survivor、old）
	对所有新生代的region进行全面的gc
	GC的结果是有一些对象进入survivor中，有一些对象会直接晋升到old分区中，一部分对象被回收
2）	并发阶段（指的是 global concurrent marking 全局并发标记）
	为接下来混合式gc提供依据，寻找哪些区域的回收性价比最高

并发标记可能会遇到两个问题：
	对象引用的变更（三色标记算法、SATB）
	新分配的对象（每个region中记录两个top-at-mark-start指针）
3）	混合模式（即Mixed GC）
包含两部分内容
	执行一次YGC
	对并发阶段标记的性价比最高的分区（这些分区都是old区）进行回收
4）	Full GC（一般是G1出现问题时发生）
	本质上 full gc并不属于g1。
	对象创建的速度特别快，垃圾回收的速度跟不上对象创建的速度，使得新生代的对象无处存放
	设置的暂停的时间间隔比较短，导致g1每次进行回收时都只回收很少的垃圾，导致内存中存活的垃圾对象过多，无法容纳新的对象
	对于以上两种情况，g1会回退成serial垃圾收集器，在这种情况下就会出现full gc，出现STW
5）	
11． 什么时候触发Mixed GC
1）	由一些参数控制，另外也控制着哪些老年代region会被选入CSet（收集集合）
2）	G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC
3）	G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入CSet
4）	G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量
5）	-XX:G1HeapRegionSize=n：设置region大小，并非是最终值
6）	-XX:MixedGCPauseMillis：g1收集过程目标时间，默认值200ms，不是硬性条件
7）	-XX:G1NewSizePercent：新生代最小值，默认5%
8）	XX:G1MaxNewSizePercent：新生代最大值，默认值60%   占据总堆内存的百分比
9）	-XX:ParallelGCThreads：STW期间，进行GC线程数
10）	-XX:ConcGCThreads=n：并发标记阶段，并行执行的线程数
11）	-XX:InitiationHeapOccupancyPercent：设置并发标记周期的Java堆占用率阈值，默认值是45%。这里的Java堆占比指的是non_young_capacity_bytes，包括old + humongous（包括老年代和大对象。。。一个对象的大小超过多少不再新生代中创建）  
12． G1收集器概览
1）	G1算法将堆划分为若干个区域（region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集器依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者survivor空间。
2）	老年代也分成很多区域，g1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，g1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片问题的存在了。
3）	在g1中，还有一种特殊的区域，叫做Humongous区域。
	如果有一个对象占用的空间达到或是超过分区容量50%以上，g1收集器就认为这是一个巨型对象
	这些巨型对象，默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。
	为了解决这个问题，g1划分了一个Humongous区，用它来专门存放巨型对象。
	如果一个H区装不下一个巨型对象，那么g1会寻找连续的H分区来存储。
	为了能找到连续的H分区，有时候不得不启动full gc。
13． G1 Young GC
1）	Young GC主要是对eden区进行gc，他在eden空间耗尽时会被触发。
	在这种情况下，eden空间的数据移动到survivor空间中，如果survivor空间不够，eden空间的部分数据会直接晋升到老年代空间。
	Survivor区的数据移动到新的survivor区中，也有部分数据晋升到老年代空间中。
	最终eden空间的数据为空，gc完成工作，应用线程继续执行。
2）	如果仅仅是gc（回收）新生代对象，我们如何找到所有的根对象呢？老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。
	G1引进了RSet的概念，它的全称是Remembered Set，作用是跟踪指向某个heap区内的对象引用
	在CMS中，也有RSet的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种point-out，在进行Young GC时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。
	Eden中会存在RSet结构，会记录下所指向本region的其他region中对象的引用（本质上是hash table， key是指向我的其他region的起始地址，value是每一个指向我的card table的index）
3）	在g1中，并没有使用point-out，这是由于一个分区太小，分区数量太多，如果是用point-out的话，会造成大量的扫描浪费，有些根本不需要gc的分区引用也扫描了。
4）	于是g1中使用了point-in老解决，point-in的意思是那些分区应用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。
5）	由于新生代有多个，那么我们需要在新生代之间记录引用吗，这是不必要的，原因在于每次gc时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。
6）	需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在g1中又引入了另外一个概念，卡表（Card Table）。每一个region更细粒度地划分为card
	一个card table 讲一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。
	卡通常较小，介于128到512字节之间。
	Card table 通常为字节数组，由card的索引（即数据下标）来标识每个分区的空间地址
	默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为“0”，即标记为脏引用，此外RSet也将这个数组下标记录下来。一般情况下，这个RSet其实是一个hash table，key是别的region的起始地址，value是一个集合，里面的元素是card table的index。
14． G1 young gc分为以下几个阶段
1）	根扫描（获取根）
	静态和本地对象被扫描
2）	更新RS
	处理dirty card 队列，更新RS
3）	处理RS
	检测从年轻代指向老年代的对象
4）	对象拷贝
	拷贝存活的对象到survivor/old区
5）	处理引用队列
	软引用、弱引用、虚引用处理
15． Mixed GC
1）	mixed gc 不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区
2）	mixed gc的步骤
	全局并发标记（global concurrent marking）
	拷贝存活对象（evacuation）
16． G1收集器的设计目标
1）	与应用线程同时工作，几乎不需要STW（与CMS类似）
2）	整理剩余空间，不产生内存碎片(CMS 只能在Full gc时，用STW整理内存碎片)
3）	GC停顿更加可控
4）	不牺牲系统的吞吐性能
5）	GC不要求额外的内存空间（CMS需要预留空间存储浮动垃圾）
17． 
七、	三色标记算法
1.	提到并发标记，我们不得不了解并发标记的三色标记算法。它描述的追踪式回收器的一种有效的方法，利用它可以推演回收器的正确性
2.	我们将对象分成三种类型：
1）	黑色：根对象，或者该对象与它的子对象都被扫描过（对象被标记了，且它的所有filed也被标记完了）
子对象：一个对象所包含或者所容纳的成员变量
追踪式：即GC Roots根搜索算法
2）	灰色：对象本身被扫描，但还没有扫描完改对象中的子对象（它的field还没有被标记或标记完）
3）	白色：未被扫描对象，扫描完成所有对象之后，最终为白色的不可达对象，即垃圾对象（对象还没有被标记到）

所谓的标记指的是这个对象是可达的，凡是被标记的对象都不应该被回收掉
标记结束后，所有可达的对象都会被标记为黑色，不可达的对象都会是白色
3.	但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题（或对象漏标问题）。解决方法：SATB
1）	例如
	一开始：
G.a=A; 
G.b=B; 
B.c=C;
	扫描中，在G、A扫描完后，即G、A为黑色，此时B为灰色（未开始扫描子对象），应用程序执行以下操作：
A.c=C；
B.c =null;
这时候，C对象就是白色的，但它实际应该是黑色的
	再继续扫描时，发现B没有子对象，则B变成黑色。此时G、A、B均为黑色，C因为未被扫描标记到，此时C仍是白色的。
2）	在G1中，使用的是SATB（Snapshot-At-The-begining）的方式，删除的时候记录所有的对象。
4.	SATB的三个步骤
1）	在开始标记的时候生成一个快照图，来标记存活对象。
通过快照图可以标记出当时所有存活的对象
2）	在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用指向的对象都变成非白的）
write barrier：写屏障，jvm内存中存在读写屏障的概念

	现状：
扫描中，在G、A扫描完后，即G、A为黑色，此时B为灰色（未开始扫描子对象）
	应用程序执行以下操作：
A.c=C；
B.c =null;
	再继续扫描时，发现B没有子对象，则B变成黑色。此时G、A、B均为黑色，C因为未被扫描标记到，此时C仍是白色的。
	此时根据SATB算法，会将改变的旧的引用所指向的对象变成非白的，即将C变为非白
	可能存在浮动垃圾：如果只修改B.c=null;  C实际上是垃圾，但是由于SATB，C变成非白的，此时C就是浮动垃圾，C将会在下一次垃圾收集时被回收
	可以容忍浮动垃圾，但是不能容忍对象被错误地回收
3）	可能存在浮动垃圾，将在下次被收集
5.	G1混合式回收（Mixed GC）
1）	G1到现在可以知道那些老的分区可回收垃圾最多。当全局并发标记完成后，在某个时刻，就开始了Mixed GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也会回收部分后台扫描线程（global concurrent marking）标记的分区。
2）	混合式GC也是采用的复制清理策略，当GC完成后，会重新释放空间
6.	G1分代算法
1）	为老年代设置分区的目的是老年代里有的分区垃圾多，有的分区垃圾少，这样在回收的时候可以专注于收集垃圾多的分区，这也是G1名称的由来
2）	不过分区（region的方式）的这个算法并不适合新生代垃圾收集（因为新生代的收集不是只回收性价比高的分区，而是全部进行收集，因此分区在此作用不大），因为新生代的垃圾收集算法是复制算法，但是新生代也是用了分区机制主要是便于代大小的调整
7.	SATB详解
1）	SATB是维持并发GC的一种手段。
	G1并发的基础就是SATB
	SATB可以理解成在GC开始之前对堆内存里的对象做一次快照，此时活的对象就认为是活的，从而形成一个对象图。
2）	在GC收集的时候，新生代的对象也认为是活的对象，除此之外其他不可达的对象都认为是垃圾
3）	如何找到在GC过程中分配的对象呢？
	每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS何nextTAMS。在TAMS以上的对象就是新分配的，因此被视为隐式marked
	通过这种方式我们就找到了再GC过程中新分配的对象，并把这些对象认为是获得对象。
4）	解决了对象在GC过程中分配的问题，那么在GC过程中引用发生改变的问题怎么解决呢？
	G1给出的解决办法是通过Write Barrier。
	Write Barrier就是对引用字段进行赋值做了额外处理。通过Write Barrier就可以了解到那些引用对象发生了什么样的变化
额外的处理：当引用发生改变时，这个引用所指向的对象变成非白
5）	SATB标记的过程
	Mark的过程就是遍历heap标记存活的对象（live object）的过程，采用的是三色标记算法。
	整个三色标记算法就是从GC Roots出发遍历heap，针对可达对象先标记为灰色，然后再标记灰色为黑色
	遍历完成之后所有可达对象都是黑色的，所有白色都是可回收的
6）	SATB仅仅对于在marking开始阶段进行“snapshot”（marked all reachable at mark start在标记开始的时候标记所有可达的对象），但是并发标记的时候并发修改可能造成对象漏标记
7）	对于三色算法在并发标记的时候可能产生的漏标记的问题，SATB在marking阶段中，对于从灰色对象移除的目标引用标记为灰色，对于黑色引用的新产生的对象标记为黑色。由于是在开始的时候进性snapshot，因为可能存在浮动垃圾
8）	漏标与误标
	误标没什么关系，顶多造成浮动垃圾，在下次gc还是可以回收的
把本应是白色的对象标记为灰色或黑色
	但是漏标的后果是致命的，把本应该存活的对象给回收了，从而影响程序的正确性。
把本应标记为灰色或黑色的对象漏标记了，对象仍然还是白色
	
9）	漏标的情况只会发生在白色对象中，且满足以下任意一个条件
	并发标记时，应用线程给一个黑色对象的引用类型字段赋值了该白色对象
因为对象是黑色的对象，那么g1就不会对这个对象再进行追踪式的标记了。当白色对象赋值给黑色对象的引用时，白色对象就没有机会被扫描标记，
	并发标记时，应用程序删除了所有灰色对象到该白色对象的引用
此时若还有一个黑色对象指向这个白色对象，则这个白色对象就会被漏标（？？？什么情况下会出现这种情况）
10）	SATB如果解决以上漏标的情况
	对于第一种情况，利用post-write barrier（写后屏障），记录所有新增的引用关系，然后以这些应用关系为根重新扫描一遍
	对于第二种情况，利用 pre-writer barrier（写前屏障），将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根重新扫描一遍
11）	
8.	G1的停顿预测模型
1）	G1收集器突出表现出来的一点是通过一个停顿预测模型根据用户配置的停顿时间来选择CSet（收集集合，里面存放准备被回收的region）的大小，从而达到用户期待的应用程序暂停时间
2）	通过-XX:MaxGCPauseMillis参数来设置，这一点有点类似于ParallelScavenge收集器。关于停顿时间的设置并不是越短越好。
9.	G1的收集模式
1）	Young GC：收集年轻代里的region
2）	Mixed GC：年轻代的所有region + 全局并发标记阶段选出的收益高的region
3）	无论是Young GC还是Mixed GC，都只是并发拷贝的阶段
10.	分代G1模式下选择CSet有两种子模式：
1）	Young GC：CSet就是所有年轻代里面的region
2）	Mixed GC：CSet是所有年轻代里的region加上在全局并发标记阶段标记出来的收益高的region

即对于G1的收集模式来说，在收集新生代时会对新生代的所有region执行一次回收，而对于老年代来说，只会选择回收那些收益到的region
11.	G1的运行过程
1）	会在Young GC和MixedGC之间不断地切换运行，同时定期地做全局并发标记，在实在赶不上对象创建速度的情况下使用Full GC（即退化为Serial GC）
2）	初始标记是在Young GC上执行的，在进行全局并发标记的时候不会做Mixed GC，在做Mixed GC的时候也不会启动初始标记阶段
3）	在Mixed GC赶不上对象产生速度的时候就退化成Full GC，这一点是需要重点调优的地方。
12.	再谈Mixed GC
1）	Mixed GC不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区
2）	它的GC步骤分为两步
	全局并发标记（global concurrent marking）
	拷贝存活对象（evacuation）
3）	在G1 GC中，global concurrent marking主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必选环节。Global concurrent marking的执行过程分为四个步骤
	初始标记（STW）
	并发标记
	重新标记（STW）
	清理
4）	

13.	G1既能回收新生代也能回收老年代。它在回收新生代和老年代所采取的方式是有很大的区别的
1）	G1在回收新生代的时候采取的是STW的方式，而且会对新生代的所有分区都进行回收。这是Young GC在g1中所采取的处理方式
2）	G1在回收老年代的时候，换言之，G1在进行Mixed GC时，采用的做法是回收所有的新生代也就是对全部的young region进行回收，同时也对global concurrent marking所标记出来的那些收益比最高的老年代进行垃圾收集
3）	G1在运行的过程中会动态调新生代和老年代的大小
4）	G1与传统的分代垃圾收集器存在明显区别
	传统的分代垃圾收集器是回收新生代，老年代一旦出现垃圾回收的话就可能产生full gc
	G1在回收老年代的时候可能不是因为产生了full gc，只有达到一定的极限条件才会产生full gc
5）	
14.	G1 GC日志分析
1）	Aa
-verbose:gc
-Xms10M
-Xmx10M
-XX:+UseG1GC
-XX:+PrintGCDetails
-XX:+PrintGCDetails
-XX:MaxGCPauseMillis=200m

 
[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0034035 secs]
   [Parallel Time: 1.4 ms, GC Workers: 8]
      [GC Worker Start (ms): Min: 129.0, Avg: 129.3, Max: 129.4, Diff: 0.4]
      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.8, Max: 1.3, Diff: 1.3, Sum: 6.3]
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Object Copy (ms): Min: 0.0, Avg: 0.3, Max: 0.9, Diff: 0.9, Sum: 2.1]
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]
         [Termination Attempts: Min: 1, Avg: 3.5, Max: 12, Diff: 11, Sum: 28]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      [GC Worker Total (ms): Min: 1.0, Avg: 1.1, Max: 1.4, Diff: 0.4, Sum: 8.9]
      [GC Worker End (ms): Min: 130.4, Avg: 130.4, Max: 130.4, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.1 ms]
   [Other: 1.9 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 1.7 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.1 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 3072.0K(4096.0K)->0.0B(2048.0K) Survivors: 0.0B->1024.0K Heap: 4186.6K(10.0M)->2908.1K(10.0M)]
 [Times: user=0.00 sys=0.00, real=0.01 secs] 
[GC concurrent-root-region-scan-start]
test
[GC concurrent-root-region-scan-end, 0.0011069 secs]
[GC concurrent-mark-start]
[GC concurrent-mark-end, 0.0000303 secs]
[GC remark [Finalize Marking, 0.0012736 secs] [GC ref-proc, 0.0000577 secs] [Unloading, 0.0005081 secs], 0.0019526 secs]
 [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC cleanup 5039K->5039K(10M), 0.0004795 secs]
 [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 garbage-first heap   total 10240K, used 4956K [0x00000000ff600000, 0x00000000ff700050, 0x0000000100000000)
  region size 1024K, 2 young (2048K), 1 survivors (1024K)
 Metaspace       used 3489K, capacity 4498K, committed 4864K, reserved 1056768K
  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K

	[GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0034035 secs]
GC 停顿（G1 巨型对象分配）（年轻代的垃圾收集）（初始标记）
	[Parallel Time: 1.4 ms, GC Workers: 8]
GC汇总的信息，并行时间1.4ms，有8个GC Worker线程在同时执行

	[GC Worker Start (ms): Min: 129.0, Avg: 129.3, Max: 129.4, Diff: 0.4]
开始垃圾回收
	[Ext Root Scanning (ms): Min: 0.0, Avg: 0.8, Max: 1.3, Diff: 1.3, Sum: 6.3]
根节点扫描
	[Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
更新记忆集合
	[Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
	记录引用变化的缓存空间
	[Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
扫描RSet所花费的时间
	[Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
根扫描的时间
	[Object Copy (ms): Min: 0.0, Avg: 0.3, Max: 0.9, Diff: 0.9, Sum: 2.1]
对象拷贝的时间
	[Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]
[Termination Attempts: Min: 1, Avg: 3.5, Max: 12, Diff: 11, Sum: 28]
GC线程执行终止之前的处理耗时（检查其他线程的队列，是否还有未清理完的引用要做处理）处理引用队列
	汇总信息
[GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
[GC Worker Total (ms): Min: 1.0, Avg: 1.1, Max: 1.4, Diff: 0.4, Sum: 8.9]
[GC Worker End (ms): Min: 130.4, Avg: 130.4, Max: 130.4, Diff: 0.0]
	[Clear CT: 0.1 ms]
清理卡表 （car table）
	[Choose CSet: 0.0 ms]
选择需要回收的集合
	[Ref Proc: 1.7 ms]
引用的处理（软引用、弱引用。。。）
	[Ref Enq: 0.0 ms]
将处理的引用入队
	[Free CSet: 0.0 ms]

	[Eden: 3072.0K(4096.0K)->0.0B(2048.0K) Survivors: 0.0B->1024.0K Heap: 4186.6K(10.0M)->2908.1K(10.0M)]
YGC执行结束后，整个堆的情况
Eden: 3072.0K(4096.0K)->0.0B(2048.0K)：eden从3072k变到0k
Survivors: 0.0B->1024.0K：survivor从0K到1024K（有一个对象晋升）
heap: 4186.6K(10.0M)->2908.1K(10.0M)]：堆从4186.6K到2908.1K

	以上为YGC，开始进入并发阶段
[GC concurrent-root-region-scan-end, 0.0011069 secs]
[GC concurrent-mark-start] 并发标记开始
[GC concurrent-mark-end, 0.0000303 secs] 并发标记结束
[GC remark [Finalize Marking, 0.0012736 secs] [GC ref-proc, 0.0000577 secs] 重新标记

	region size 1024K, 2 young (2048K), 1 survivors (1024K)
分区大小：1024K，有两个region作为young，一个survivor region；则其他的region作为old
	
2）	
15.	
八、	G1最佳实践
1.	不断调优暂停时间指标
1）	通过 -XX:MaxGCPauseMillis=x 可以设置启动应用程序暂停的时间，G1在运行的时候会根据这个参数选择CSet来满足响应时间的设置。
	一般情况下这个值设置到100ms或者200ms都是可以的（不同情况下会不一样），但如果设置成50ms就不太合理。
	暂停时间设置太短，就会导致出现G1跟不上垃圾产生的速度，最终退化成full gc。
	所以对这个参数调优是一个持续的过程，逐步调整到最佳状态。
2）	根据垃圾回收的日志这些具体的输出信息来不断地进行调优具体的参数值

2.	不要设置新生代和老年代的大小，而是为整个堆指定大小
1）	G1收集器在运行的时候会调整新生代和老年代的大小。通过改变代的大小来调整对象晋升的速度以及晋升年龄，从而达到我们为收集器设置的暂停时间的目标
2）	设置了新生代的大小相当于放弃了G1为我们做的自动调优。我们需要做的只是设置整个堆内存的大小，剩下的交给G1自己去分配各个代的大小即可。
3.	关注Evacuation Failure（复制失败，表示从源region将存活对象拷贝到目标region时，发现没有能够容纳下待拷贝对象的region大小，需要进行一次full gc进行空间的整理）
1）	Evacuation Failure类似于CMS里面的晋升失败，堆空间垃圾太多导致无法完成region之间的拷贝，于是不得不退化成Full GC来做一次全局范围内的垃圾收集
2）	
4.	
九、	
1.	
十、	
